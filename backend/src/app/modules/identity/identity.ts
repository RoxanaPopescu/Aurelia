import jwt from "jsonwebtoken";
import jwksRsa from "jwks-rsa";
import { ApiResult } from "shared/infrastructure";
import { environment } from "../../../env";
import settings from "../../../resources/settings/settings";
import { Base64 } from "../../../shared/utilities";
import { AppModule } from "../../app-module";

/**
 * Represents a module exposing endpoints related to authentication and authorization.
 */
export class IdentityModule extends AppModule
{
    private readonly _verifyOptions: jwt.VerifyOptions =
    {
        issuer: settings.middleware.authorize.accessToken.issuer
    };

    private readonly _jwksRsaClient = jwksRsa(
    {
        jwksUri: `https://test-mover.azure-api.net/identity/.well-known/openid-configuration/jwks?subscription-key=${environment.subscriptionKey}`
    });

    private readonly _getKeyFunc = (header: any, callback: any) =>
    {
        this._jwksRsaClient.getSigningKey(header.kid, (error: any, key: any) =>
            callback(error, key?.publicKey || key?.rsaPublicKey));
    };

    public configure(): void
    {
        /**
         * Gets the sign in URL for the specified OAuth identity provider.
         * @param params.providerId The ID of the provider to get.
         * @param body.redirectUrl The URL to redirect to when authentication succeeds.
         * @param body.codeChallenge The code challenge created by hashing the code verifier.
         * @returns
         * - 200: The sign in URL for the specified OAuth identity provider.
         */
        this.router.post("/v2/identity/providers/:providerId/get-url", async context =>
        {
            // TODO: How do we specify which provider to use?
            // TODO: We should probably rely on the `x-api-key` header instead of a client ID.
            // TODO: What should state and nonce be?

            const result = await this.apiClient.get("identity/connect/authorize",
            {
                query:
                {
                    "subscription-key": settings.app.oAuth.subscrioptionKey,
                    "client_id": "bff",
                    "scope": "openid profile email organization-selection",
                    "response_type": "code",
                    "redirect_uri": context.request.body.redirectUrl,
                    "code_challenge": context.request.body.codeChallenge,
                    "code_challenge_method": "S256",
                    "nonce": "TODO",
                    "state": "TODO"
                },
                redirect: "manual"
            });

            context.response.body =
            {
                url: result.response.headers.get("location")
            };

            context.response.status = 200;
        });

        /**
         * Authenticates the user, based the specified OAuth identity provider and code.
         * Note that if the user does not exist, it will be created based on the info received from the identity provider.
         * @param params.providerId The ID of the provider to use.
         * @param body.redirectUrl The redirect URI specified when authenticating with the provider.
         * @param body.codeVerifier The code verifier generated by the client, based on which the code challenge was created.
         * @param body.code The code received in the redirect from the identity provider.
         * @returns
         * - 200: A refresh token and an access token that grants permission to create or choose an organization.
         */
        this.router.post("/v2/identity/providers/:providerId/authenticate", async context =>
        {
            // TODO: How do we specify which provider was used?

            const body =
                `client_id=bff&` +
                `client_secret=${settings.app.oAuth.clientSecret}&` +
                `grant_type=authorization_code&` +
                `redirect_uri=${context.request.body.redirectUrl}&` +
                `code_verifier=${context.request.body.codeVerifier}&` +
                `code=${context.request.body.code}`;

            const result = await this.apiClient.post("identity/connect/token",
            {
                body
            });

            context.response.body = await this.getAuthResponse(result);
            context.response.status = 200;
        });

        /**
         * Authenticates the user, based on the specified email and password.
         * @param body.email The email address identifying the user.
         * @param body.password The users password.
         * @returns
         * - 200: A refresh token and an access token that grants permission to create or choose an organization.
         */
        this.router.post("/v2/identity/authenticate", async context =>
        {
            const body =
                `client_id=bff.localUserPassword&` +
                `client_secret=${settings.app.oAuth.clientSecret}&` +
                `scope=openid profile email organization-selection offline_access&` +
                `grant_type=password&` +
                `username=${context.request.body.email}&` +
                `password=${context.request.body.password}`

            const result = await this.apiClient.post("identity/connect/token",
            {
                headers:
                {
                    "content-type": "application/x-www-form-urlencoded"
                },
                body
            });

            context.response.body = await this.getAuthResponse(result);
            context.response.status = 200;
        });

        /**
         * Authorizes the user, based on the specified access token and organization.
         * @param body.organizationId The ID of the organization for which to get an access token, if any.
         * @returns
         * - 200: A refresh token and an access token that grants permission to create or choose an organization,
         *   and additional permissions within the specified organization.
         */
        this.router.post("/v2/identity/authorize", async context =>
        {
            const result = await this.apiClient.post("identity/tokenExchange",
            {
                body:
                {
                    organizationId: context.request.body.organizationId
                }
            });

            context.response.body = await this.getAuthResponse(result);
            context.response.status = 200;
        });

        /**
         * Reauthorizes the user, based on the specified refresh token, and optionbally, access token.
         * @param body.refreshToken The refresh token for which to get an access token.
         * @returns
         * - 200: A refresh token and an access token that grants permission to create or choose an organization,
         *   and if an access token for an organization was specified, additional permissions within that organization.
         */
        this.router.post("/v2/identity/reauthorize", async context =>
        {
            const body =
                `client_id=bff.localUserPassword&` +
                `grant_type=refresh_token&` +
                `refresh_token=${context.request.body.refreshToken}`;

            const result = await this.apiClient.post("identity/connect/token",
            {
                headers:
                {
                    "content-type": "application/x-www-form-urlencoded"
                },
                body
            });

            context.response.body = await this.getAuthResponse(result);
            context.response.status = 200;
        });

        /**
         * Unauthenticates the user, by revoking the specified refresh token.
         * @param body.refreshToken The refresh token to revoke.
         * @returns
         * - 204: No content.
         */
        this.router.post("/v2/identity/unauthenticate", async context =>
        {
            await context.authorize();

            const body =
                `token=${context.request.body.refreshToken}&` +
                `token_type_hint=refresh_token`;

            await this.apiClient.post("identity/connect/revocation",
            {
                headers:
                {
                    "content-type": "application/x-www-form-urlencoded",
                    "authorization": Base64.encode(`bff.localUserPassword:${settings.app.oAuth.clientSecret}`)
                },
                body
            });

            context.response.status = 204;
        });
    }

    private async getAuthResponse(authResult: ApiResult): Promise<any>
    {
        const jwtObject = await new Promise<any>((resolve, reject) =>
        {
            jwt.verify(authResult.data.access_token, this._getKeyFunc, this._verifyOptions, (error, decoded) =>
                error ? reject(error) : resolve(decoded));
        });

        const [result1, result2] = await Promise.all(
        [
            this.apiClient.get("identity/connect/userinfo",
            {
                headers:
                {
                    "authorization": `Bearer ${authResult.data.access_token}`
                }
            }),
            jwtObject.organization == null ? undefined : this.apiClient.get("organizations/GetOrganization",
            {
                headers:
                {
                    "authorization": `Bearer ${authResult.data.access_token}`
                },
                query:
                {
                    id: jwtObject.organization
                }
            })
        ]);

        return {
            accessToken: result1.data.access_token ?? result1.data.accessToken,
            refreshToken: result1.data.refresh_token ?? result1.data.refreshToken,
            id: result1.data.id,
            email: result1.data.email,
            fullName: result1.data.name,
            preferredName: result1.data.preferred_username,
            pictureUrl: result1.data.picture,
            outfit: result2 == null ? undefined :
            {
                id: result2.data.organizationId,
                companyName: result2.data.name
            }
        };
    }
}
