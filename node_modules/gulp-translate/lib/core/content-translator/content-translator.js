"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContentTranslator = void 0;
var tslib_1 = require("tslib");
var cheerio = tslib_1.__importStar(require("cheerio"));
/**
 * Represents a base class for translators, which implements the basic parsing of included and excluded content,
 * while leaving the actual text translation to the concrete implementation.
 */
var ContentTranslator = /** @class */ (function () {
    /**
     * Creates a new instance of the PseudoContentTranslator type.
     * @param templateParserConfig The TemplateParserConfig instance.
     * @param templateLanguage The ITemplateLanguage instance.
     */
    function ContentTranslator(templateParserConfig, templateLanguage) {
        this.templateParserConfig = templateParserConfig;
        this.templateLanguage = templateLanguage;
    }
    /**
     * Translates the specified content, producing pseudo-translated content suitable for identifying localization issues.
     * @param templateHtml The content that should be translated.
     * @returns The translated content.
     */
    ContentTranslator.prototype.translate = function (templateHtml) {
        // Extract any expressions to ensure we only parse standard HTML.
        var expressions = [];
        var standardHtml = this.templateLanguage.toStandardHtml(templateHtml, expressions);
        // Parse the template as HTML to get the CheerioStatic instance.
        var $ = cheerio.load(standardHtml, { decodeEntities: false, lowerCaseTags: false, lowerCaseAttributeNames: false });
        // Get the auto-created root node.
        var root = $.root().get(0);
        // Parse the node tree, starting from the root node.
        this.parseNode(root, true);
        // Inject the previously extracted binding expressions back into the template.
        return this.templateLanguage.toTemplateHtml($.html(), expressions);
    };
    /**
     * Recursively parses and translates the element tree and its attributes, starting with the specified element.
     * @param $ The CheerioStatic instance.
     * @param element The element representing the root of the tree.
     * @param translate True if the element should be translated, otherwise false.
     */
    ContentTranslator.prototype.parseNode = function (element, translate) {
        var e_1, _a, e_2, _b;
        // Ignore the node if it does not represent an HTML element.
        if (element.type === "text") {
            // Should the text be translated?
            if (translate) {
                element.nodeValue = this.translateText(element.nodeValue);
            }
        }
        // Ignore the node if it does not represent an HTML element.
        if (element.type !== "root" && element.type !== "tag") {
            return;
        }
        var translateChildren = translate;
        // Try to find the translate attribute on the element.
        if (this.templateParserConfig.attributeName in element.attribs) {
            // Should the child nodes be translated?
            translateChildren = element.attribs[this.templateParserConfig.attributeName] !== "no";
        }
        try {
            // Parse the element attributes.
            for (var _c = tslib_1.__values(Object.keys(element.attribs)), _d = _c.next(); !_d.done; _d = _c.next()) {
                var attrName = _d.value;
                this.parseAttribute(element, attrName);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        try {
            // Parse child elements of the element.
            for (var _e = tslib_1.__values(element.children), _f = _e.next(); !_f.done; _f = _e.next()) {
                var childElement = _f.value;
                this.parseNode(childElement, translateChildren);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    /**
     * Parses and translates the specified attribute.
     * @param $ The CheerioStatic instance.
     * @param element The element representing the root of the tree.
     * @param attrName The name of the attribute.
     */
    ContentTranslator.prototype.parseAttribute = function (element, attrName) {
        // Try to get the name of the target attribute.
        var targetAttrName = this.templateParserConfig.attributePattern.getTargetName(attrName);
        // Ignore the node if it does not match the attribute pattern.
        if (targetAttrName == null) {
            return;
        }
        // Should the attribute be translated?
        if (!(targetAttrName in element.attribs)) {
            element.attribs[targetAttrName] = this.translateText(element.attribs[targetAttrName]);
        }
        else if (element.attribs[attrName] !== "no") {
            element.attribs[attrName] = this.translateText(element.attribs[attrName]);
        }
    };
    return ContentTranslator;
}());
exports.ContentTranslator = ContentTranslator;
//# sourceMappingURL=content-translator.js.map