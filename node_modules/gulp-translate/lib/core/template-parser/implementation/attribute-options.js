"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AttributeOptions = void 0;
var tslib_1 = require("tslib");
var chalk_1 = tslib_1.__importDefault(require("chalk"));
/**
 * Represents a base class for attribute options, which provides methods for parsing and stringifying the options.
 */
var AttributeOptions = /** @class */ (function () {
    function AttributeOptions() {
    }
    /**
     * Stringifies the specified options.
     * @param options The options instance to stringify.
     * @returns An options string representing the options.
     */
    AttributeOptions.prototype.stringify = function (options) {
        return options ? Object.keys(options).map(function (key) { return key + ": " + options[key].toString().replace(/;/g, "\\;"); }).join("; ") : "";
    };
    /**
     * Parses the specified attribute value.
     * @param attrValue The attribute value to parse.
     * @returns An object representing the options.
     */
    AttributeOptions.prototype.parse = function (attrValue) {
        var options = {};
        var i = 0;
        while (i < attrValue.length) {
            skipWhitespace(attrValue);
            if (i === attrValue.length) {
                return options;
            }
            var name_1 = parseName(attrValue);
            skipWhitespace(attrValue);
            var value = parseValue(attrValue);
            skipWhitespace(attrValue);
            options[name_1] = value;
        }
        if (i !== attrValue.length) {
            throw new Error("Expected property name at position " + chalk_1.default.magenta(i.toString()) + " in attribute value '" + chalk_1.default.cyan(attrValue) + "'.");
        }
        return options;
        /* tslint:disable: no-shadowed-variable */
        function skipWhitespace(attrValue) {
            while (i < attrValue.length && /\s/.test(attrValue[i])) {
                i++;
            }
        }
        function parseName(attrValue) {
            var start = i;
            while (i < attrValue.length && /[a-z-]/.test(attrValue[i])) {
                i++;
            }
            if (i === start || attrValue[start] === "-" || attrValue[i - 1] === "-") {
                throw new Error("Expected property name at position " + chalk_1.default.magenta(start.toString()) + " in attribute value '" + chalk_1.default.cyan(attrValue) + "'.");
            }
            var result = attrValue.slice(start, i);
            skipWhitespace(attrValue);
            if (attrValue[i] !== ":") {
                throw new Error("Expected '" + chalk_1.default.cyan(":") + "' at position " + chalk_1.default.magenta(i.toString()) + " in attribute value '" + chalk_1.default.cyan(attrValue) + "'.");
            }
            i++;
            return result;
        }
        function parseValue(attrValue) {
            var start = i;
            var char = attrValue[start];
            var trimStart = 0;
            var trimEnd = 0;
            var quote = null;
            var escape = false;
            var done = false;
            if (/["'`]/.test(char)) {
                quote = char;
                trimStart = 1;
                char = attrValue[++i];
            }
            while (char != null) {
                if (escape) {
                    escape = false;
                }
                else {
                    if (char === "\\") {
                        escape = true;
                    }
                    else {
                        if (char === quote && !done) {
                            trimEnd++;
                            done = true;
                        }
                        else {
                            if (char === ";") {
                                break;
                            }
                            if (/\s/.test(char)) {
                                trimEnd++;
                            }
                            else {
                                if (done) {
                                    throw new Error("Expected '" + chalk_1.default.cyan(";") + "' at position " + chalk_1.default.magenta(i.toString()) + " in attribute value '" + chalk_1.default.cyan(attrValue) + "'.");
                                }
                                trimEnd = 0;
                            }
                        }
                        escape = false;
                    }
                }
                char = attrValue[++i];
            }
            if (i === start) {
                throw new Error("Expected property value at position " + chalk_1.default.magenta(start.toString()) + " in attribute value '" + chalk_1.default.cyan(attrValue) + "'.");
            }
            if (escape) {
                throw new Error("Expected character at position " + chalk_1.default.magenta(i.toString()) + " in attribute value '" + chalk_1.default.cyan(attrValue) + "'.");
            }
            if (quote && !done) {
                throw new Error("Expected '" + chalk_1.default.cyan(quote) + "' at position " + chalk_1.default.magenta(i.toString()) + " in attribute value '" + chalk_1.default.cyan(attrValue) + "'.");
            }
            var result = attrValue.slice(start - trimStart, i - trimEnd);
            if (char === ";") {
                i++;
            }
            return result;
        }
        /* tslint:enable */
    };
    return AttributeOptions;
}());
exports.AttributeOptions = AttributeOptions;
//# sourceMappingURL=attribute-options.js.map