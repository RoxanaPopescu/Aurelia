"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Template = exports.AnnotationOptions = exports.AttributeAnnotation = exports.ElementAnnotation = exports.Annotation = exports.AttributeContent = exports.ElementContent = exports.Content = void 0;
var tslib_1 = require("tslib");
var chalk_1 = tslib_1.__importDefault(require("chalk"));
var content_whitespace_1 = require("../../content-whitespace/content-whitespace");
var attribute_options_1 = require("./attribute-options");
// Contains the ids of all exported content instances, mapped to the hash of the content.
// This allows us to verify that we never associate different content instances with the same id.
var hashMap = {};
/**
 * Represents a base class for content parsed from a template.
 */
var Content = /** @class */ (function () {
    function Content(expressions, contentHash, templateLanguage, templateWhitespace) {
        this.expressions = expressions;
        this.contentHash = contentHash;
        this.templateLanguage = templateLanguage;
        this.templateWhitespace = templateWhitespace;
    }
    Object.defineProperty(Content.prototype, "id", {
        get: function () {
            var hash = this.contentHash.compute(this.content, this.annotation.options.hint);
            var cachedHash = hashMap[this.annotation.options.id || hash] || (hashMap[this.annotation.options.id || hash] = hash);
            if (cachedHash !== hash) {
                throw new Error("An id collision was detected for id '" + chalk_1.default.cyan(this.annotation.options.id || hash) + "'. The id is associated with multiple different content instances.");
            }
            return this.annotation.options.id || hash;
        },
        enumerable: false,
        configurable: true
    });
    return Content;
}());
exports.Content = Content;
/**
 * Represents content parsed from an element in a template.
 */
var ElementContent = /** @class */ (function (_super) {
    tslib_1.__extends(ElementContent, _super);
    function ElementContent(annotation, expressions, contentHash, templateLanguage, templateWhitespace) {
        var _this = _super.call(this, expressions, contentHash, templateLanguage, templateWhitespace) || this;
        _this.annotation = annotation;
        return _this;
    }
    Object.defineProperty(ElementContent.prototype, "content", {
        get: function () {
            var standardHtml = this.annotation.element.html();
            if (standardHtml == null) {
                throw new Error("Element has no content.");
            }
            var normalizedHtml = this.templateWhitespace.normalize(standardHtml, this.whitespace);
            return this.templateLanguage.toTemplateHtml(normalizedHtml, this.expressions);
        },
        set: function (templateHtml) {
            var standardHtml = this.templateLanguage.toStandardHtml(templateHtml, this.expressions);
            this.annotation.element.html(standardHtml);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ElementContent.prototype, "whitespace", {
        get: function () {
            return this.annotation.options.whitespace || this.templateWhitespace.getDefault(this.annotation.element[0].tagName);
        },
        enumerable: false,
        configurable: true
    });
    return ElementContent;
}(Content));
exports.ElementContent = ElementContent;
/**
 * Represents content parsed from an attribute in a template.
 */
var AttributeContent = /** @class */ (function (_super) {
    tslib_1.__extends(AttributeContent, _super);
    function AttributeContent(annotation, expressions, contentHash, templateLanguage, templateWhitespace) {
        var _this = _super.call(this, expressions, contentHash, templateLanguage, templateWhitespace) || this;
        _this.annotation = annotation;
        return _this;
    }
    Object.defineProperty(AttributeContent.prototype, "content", {
        get: function () {
            var standardHtml = this.annotation.element.attr(this.annotation.contentAttrName);
            var normalizedHtml = this.templateWhitespace.normalize(standardHtml, this.whitespace);
            return this.templateLanguage.toTemplateHtml(normalizedHtml, this.expressions);
        },
        set: function (templateHtml) {
            var standardHtml = this.templateLanguage.toStandardHtml(templateHtml, this.expressions);
            // TODO: Ideally, we should only encode the quotes if they are the same as the surrounding quotes.
            // Ensure quotes are encoded, as they might otherwise break the HTML by ending the attribute value prematurely.
            standardHtml = standardHtml
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&apos;");
            this.annotation.element.attr(this.annotation.contentAttrName, standardHtml);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AttributeContent.prototype, "whitespace", {
        get: function () {
            return this.annotation.options.whitespace || this.templateWhitespace.getDefault(this.annotation.element[0].tagName, this.annotation.targetAttrName);
        },
        enumerable: false,
        configurable: true
    });
    return AttributeContent;
}(Content));
exports.AttributeContent = AttributeContent;
/**
 * Represents a base class for annotations parsed from a template.
 */
var Annotation = /** @class */ (function () {
    function Annotation(element, annotationAttrName, isNested, isDirectAnnotation) {
        this.element = element;
        this.annotationAttrName = annotationAttrName;
        this.isNested = isNested;
        var annotationAttrValue = element.attr(annotationAttrName);
        this.translate = annotationAttrValue !== "no";
        if (!isDirectAnnotation && annotationAttrValue !== "yes" && annotationAttrValue !== "no") {
            this.options = new AnnotationOptions(annotationAttrValue);
            this.hasOptions = /\S/.test(annotationAttrValue);
        }
        else {
            this.options = new AnnotationOptions();
            this.hasOptions = false;
        }
        // If this is a direct annotation, determine whether it might actually be an orphaned annotation.
        if (isDirectAnnotation) {
            if (annotationAttrValue === "" || annotationAttrValue === "yes" || annotationAttrValue === "no") {
                this.isSuspectedOrphan = true;
            }
            else {
                try {
                    /* tslint:disable-next-line: no-unused-expression */
                    new AnnotationOptions(annotationAttrValue);
                    this.isSuspectedOrphan = true;
                }
                catch (error) {
                    // The value does not look like options, so no problem.
                }
            }
        }
    }
    return Annotation;
}());
exports.Annotation = Annotation;
/**
 * Represents an annotation parsed from an element in a template.
 */
var ElementAnnotation = /** @class */ (function (_super) {
    tslib_1.__extends(ElementAnnotation, _super);
    function ElementAnnotation(element, annotationAttrName, isNested) {
        return _super.call(this, element, annotationAttrName, isNested, false) || this;
    }
    ElementAnnotation.prototype.clean = function (preserveAnnotations) {
        switch (preserveAnnotations) {
            case "all":
                return;
            case "none":
                this.element.removeAttr(this.annotationAttrName);
                break;
            case "standard":
                this.element.removeAttr(this.annotationAttrName);
                if (this.isNested || !this.translate) {
                    this.element.attr("translate", this.translate ? "yes" : "no");
                }
                break;
            case "normalize":
                this.element.removeAttr(this.annotationAttrName);
                this.element.attr(this.annotationAttrName, this.translate ? "yes" : "no");
                break;
        }
    };
    return ElementAnnotation;
}(Annotation));
exports.ElementAnnotation = ElementAnnotation;
/**
 * Represents an annotation parsed from an attribute in a template.
 */
var AttributeAnnotation = /** @class */ (function (_super) {
    tslib_1.__extends(AttributeAnnotation, _super);
    function AttributeAnnotation(element, annotationAttrName, targetAttrName, contentAttrName, isNested) {
        var _this = _super.call(this, element, annotationAttrName, isNested, contentAttrName === annotationAttrName) || this;
        _this.targetAttrName = targetAttrName;
        _this.contentAttrName = contentAttrName;
        return _this;
    }
    AttributeAnnotation.prototype.clean = function (preserveAnnotations) {
        switch (preserveAnnotations) {
            case "all":
                return;
            case "none":
            case "standard":
                if (this.contentAttrName !== this.annotationAttrName) {
                    this.element.removeAttr(this.annotationAttrName);
                }
                else {
                    var content = this.element.attr(this.contentAttrName);
                    this.element.removeAttr(this.annotationAttrName);
                    this.contentAttrName = this.targetAttrName;
                    this.element.attr(this.contentAttrName, content);
                }
                break;
            case "normalize":
                if (this.contentAttrName !== this.annotationAttrName) {
                    this.element.removeAttr(this.annotationAttrName);
                    this.element.attr(this.annotationAttrName, this.translate ? "yes" : "no");
                }
                else {
                    var content = this.element.attr(this.contentAttrName);
                    this.element.removeAttr(this.annotationAttrName);
                    this.contentAttrName = this.annotationAttrName;
                    this.element.attr(this.contentAttrName, content);
                    this.element.attr(this.annotationAttrName, this.translate ? "yes" : "no");
                }
                break;
        }
    };
    return AttributeAnnotation;
}(Annotation));
exports.AttributeAnnotation = AttributeAnnotation;
/**
 * Represents the options specified in a translation attribute.
 */
var AnnotationOptions = /** @class */ (function (_super) {
    tslib_1.__extends(AnnotationOptions, _super);
    function AnnotationOptions(attrValue) {
        var _this = _super.call(this) || this;
        if (!attrValue) {
            return _this;
        }
        var options = _this.parse(attrValue);
        if (options.hint) {
            _this.hint = options.hint;
        }
        if (options.context) {
            _this.context = options.context;
        }
        if (options.whitespace) {
            if (content_whitespace_1.whitespaceOptions.indexOf(options.whitespace) < 0) {
                throw new Error("The '" + chalk_1.default.cyan("whitespace") + "' option must be " + content_whitespace_1.whitespaceOptions.map(function (o) { return "'" + chalk_1.default.cyan(o) + "'"; }).join(", ") + " or " + chalk_1.default.cyan("undefined") + ".");
            }
            _this.whitespace = options.whitespace;
        }
        if (options.id) {
            _this.id = options.id;
        }
        if (options.export) {
            if (options.export !== "true" && options.export !== "false") {
                throw new Error("The '" + chalk_1.default.cyan("export") + "' option must be '" + chalk_1.default.cyan("true") + "', '" + chalk_1.default.cyan("false") + "' or " + chalk_1.default.cyan("undefined") + ".");
            }
            _this.export = options.export === "true";
        }
        return _this;
    }
    return AnnotationOptions;
}(attribute_options_1.AttributeOptions));
exports.AnnotationOptions = AnnotationOptions;
/**
 * Represents the result of parsing a template instance.
 */
var Template = /** @class */ (function () {
    function Template(document, expressions, contents, annotations, templateLanguage) {
        this.document = document;
        this.expressions = expressions;
        this.contents = contents;
        this.annotations = annotations;
        this.templateLanguage = templateLanguage;
    }
    Template.prototype.toString = function () {
        return this.templateLanguage.toTemplateHtml(this.document.html(), this.expressions);
    };
    Template.prototype.clean = function (preserveAnnotations) {
        var e_1, _a;
        try {
            for (var _b = tslib_1.__values(this.annotations), _c = _b.next(); !_c.done; _c = _b.next()) {
                var annotation = _c.value;
                annotation.clean(preserveAnnotations);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    return Template;
}());
exports.Template = Template;
//# sourceMappingURL=template.js.map