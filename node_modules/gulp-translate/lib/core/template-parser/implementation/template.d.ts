/// <reference types="cheerio" />
import { IContentHash } from "../../content-hash/content-hash";
import { ITemplateLanguage } from "../../template-language/template-language";
import { IContentWhitespace, WhitespaceOption } from "../../content-whitespace/content-whitespace";
import { ITemplate, IAnnotationOptions, IAnnotation, IContent, AnnotationsOption } from "../template-parser";
import { AttributeOptions } from "./attribute-options";
/**
 * Represents a base class for content parsed from a template.
 */
export declare abstract class Content implements IContent {
    protected readonly expressions: string[];
    protected readonly contentHash: IContentHash;
    protected readonly templateLanguage: ITemplateLanguage;
    protected readonly templateWhitespace: IContentWhitespace;
    constructor(expressions: string[], contentHash: IContentHash, templateLanguage: ITemplateLanguage, templateWhitespace: IContentWhitespace);
    abstract readonly annotation: Annotation;
    abstract get content(): string;
    abstract set content(content: string);
    get id(): string;
}
/**
 * Represents content parsed from an element in a template.
 */
export declare class ElementContent extends Content {
    constructor(annotation: ElementAnnotation, expressions: string[], contentHash: IContentHash, templateLanguage: ITemplateLanguage, templateWhitespace: IContentWhitespace);
    readonly annotation: ElementAnnotation;
    get content(): string;
    set content(templateHtml: string);
    private get whitespace();
}
/**
 * Represents content parsed from an attribute in a template.
 */
export declare class AttributeContent extends Content {
    constructor(annotation: AttributeAnnotation, expressions: string[], contentHash: IContentHash, templateLanguage: ITemplateLanguage, templateWhitespace: IContentWhitespace);
    readonly annotation: AttributeAnnotation;
    get content(): string;
    set content(templateHtml: string);
    private get whitespace();
}
/**
 * Represents a base class for annotations parsed from a template.
 */
export declare abstract class Annotation implements IAnnotation {
    protected isNested: boolean;
    constructor(element: Cheerio, annotationAttrName: string, isNested: boolean, isDirectAnnotation: boolean);
    readonly element: Cheerio;
    readonly annotationAttrName: string;
    readonly translate: boolean;
    readonly options: AnnotationOptions;
    readonly hasOptions: boolean;
    readonly isSuspectedOrphan: boolean;
    abstract clean(preserveAnnotations: AnnotationsOption): void;
}
/**
 * Represents an annotation parsed from an element in a template.
 */
export declare class ElementAnnotation extends Annotation {
    constructor(element: Cheerio, annotationAttrName: string, isNested: boolean);
    clean(preserveAnnotations: AnnotationsOption): void;
}
/**
 * Represents an annotation parsed from an attribute in a template.
 */
export declare class AttributeAnnotation extends Annotation {
    constructor(element: Cheerio, annotationAttrName: string, targetAttrName: string, contentAttrName: string, isNested: boolean);
    readonly targetAttrName: string;
    contentAttrName: string;
    clean(preserveAnnotations: AnnotationsOption): void;
}
/**
 * Represents the options specified in a translation attribute.
 */
export declare class AnnotationOptions extends AttributeOptions implements IAnnotationOptions {
    constructor(attrValue?: string);
    hint?: string;
    context?: string;
    whitespace?: WhitespaceOption;
    id?: string;
    export?: boolean;
}
/**
 * Represents the result of parsing a template instance.
 */
export declare class Template implements ITemplate {
    private readonly document;
    private readonly expressions;
    private readonly templateLanguage;
    constructor(document: CheerioStatic, expressions: string[], contents: IContent[], annotations: IAnnotation[], templateLanguage: ITemplateLanguage);
    readonly contents: IContent[];
    readonly annotations: IAnnotation[];
    toString(): string;
    clean(preserveAnnotations: AnnotationsOption): void;
}
