"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CheerioTemplateParser = void 0;
var tslib_1 = require("tslib");
var cheerio = tslib_1.__importStar(require("cheerio"));
var chalk_1 = tslib_1.__importDefault(require("chalk"));
var template_1 = require("./template");
/**
 * Represents a parser that parses localizable content instances from an HTML string.
 */
var CheerioTemplateParser = /** @class */ (function () {
    /**
     * Creates a new instance of the CheerioTemplateParser type.
     * @param config The TemplateParserConfig instance.
     * @param templateLanguage The ITemplateLanguage instance.
     * @param templateWhitespace The ITemplateWhitespace instance.
     * @param contentHash The IContentHash instance.
     */
    function CheerioTemplateParser(config, templateLanguage, templateWhitespace, contentHash) {
        this.templateLanguage = templateLanguage;
        this.templateWhitespace = templateWhitespace;
        this.contentHash = contentHash;
        this.config = config;
    }
    /**
     * Gets all the localizable content from the specified HTML string.
     * @param html The HTML string representing the template from which the localizable content should be parsed.
     * @returns An ITemplate instance containing the localizable content found in the template.
     */
    CheerioTemplateParser.prototype.parse = function (template) {
        var contents = [];
        var annotations = [];
        // Extract any expressions to ensure we only parse standard HTML.
        var expressions = [];
        var standardHtml = this.templateLanguage.toStandardHtml(template, expressions);
        // Parse the template as HTML to get the CheerioStatic instance.
        var $ = cheerio.load(standardHtml, { decodeEntities: false, lowerCaseTags: false, lowerCaseAttributeNames: false });
        // Get the auto-created root node.
        var root = $.root().get(0);
        // Parse the node tree, starting from the root node.
        this.parseNode($, root, expressions, contents, annotations, false, null);
        // Return a template instance.
        return new template_1.Template($, expressions, contents, annotations, this.templateLanguage);
    };
    /**
     * Recursively parses the element tree and its attributes, starting with the specified element.
     * @param $ The CheerioStatic instance.
     * @param element The element representing the root of the tree.
     * @param expressions The array containing the original expressions for the placeholders in the template.
     * @param contents The array to which exported content instances should be added.
     * @param annotations The array to which extracted annotation instances should be added.
     * @param extract True if the element or one of its ancestor elements should be exported, otherwise false.
     * @param translate True if the element should be translated, otherwise false.
     */
    CheerioTemplateParser.prototype.parseNode = function ($, element, expressions, contents, annotations, extract, translate) {
        var e_1, _a, e_2, _b;
        // Ignore the node if it does not represent an HTML element.
        if (element.type !== "root" && element.type !== "tag") {
            return;
        }
        var extractChildren = extract;
        var translateChildren = translate;
        // Try to find the translate attribute on the element.
        if (this.config.attributeName in element.attribs) {
            var annotation = new template_1.ElementAnnotation($(element), this.config.attributeName, translate != null);
            if (!extract) {
                if (!annotation.translate) {
                    if (translate === false) {
                        throw new Error("A translate annotation within a non-translatable element can only contain the value '' or '" + chalk_1.default.cyan("yes") + "'.");
                    }
                    translateChildren = false;
                    extractChildren = false;
                }
                else if (!annotation.hasOptions) {
                    // Add the element content to the content list.
                    contents.push(new template_1.ElementContent(annotation, expressions, this.contentHash, this.templateLanguage, this.templateWhitespace));
                    translateChildren = true;
                    extractChildren = true;
                }
                else {
                    // Add the element content to the content list.
                    contents.push(new template_1.ElementContent(annotation, expressions, this.contentHash, this.templateLanguage, this.templateWhitespace));
                    translateChildren = true;
                    extractChildren = true;
                }
            }
            else {
                if (!annotation.translate) {
                    if (!translate) {
                        throw new Error("A translate annotation within a non-translatable element can only contain the value '' or '" + chalk_1.default.cyan("yes") + "'.");
                    }
                    translateChildren = false;
                }
                else if (!annotation.hasOptions) {
                    if (translate) {
                        throw new Error("A translate annotation within a translatable element can only contain the value '" + chalk_1.default.cyan("no") + "'.");
                    }
                    translateChildren = true;
                }
                else {
                    throw new Error("A translate annotation within translatable content can only contain the value '', '" + chalk_1.default.cyan("yes") + "' or '" + chalk_1.default.cyan("no") + "'.");
                }
            }
            // Add the annotation to the annotation list, so it can be cleaned later.
            annotations.push(annotation);
        }
        try {
            // Parse the element attributes.
            for (var _c = tslib_1.__values(Object.keys(element.attribs)), _d = _c.next(); !_d.done; _d = _c.next()) {
                var attrName = _d.value;
                this.parseAttribute($, element, attrName, contents, annotations, expressions, extract, translate);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        try {
            // Parse child elements of the element.
            for (var _e = tslib_1.__values(element.children), _f = _e.next(); !_f.done; _f = _e.next()) {
                var childElement = _f.value;
                this.parseNode($, childElement, expressions, contents, annotations, extractChildren, translateChildren);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    /**
     * Parses the specified attribute.
     * @param $ The CheerioStatic instance.
     * @param element The element representing the root of the tree.
     * @param attrName The name of the attribute.
     * @param contents The array to which exported content instances should be added.
     * @param annotations The array to which extracted annotation instances should be added.
     * @param expressions The array containing the original expressions for the placeholders in the template.
     * @param extract True if the element or one of its ancestor elements should be exported, otherwise false.
     * @param translate True if the element should be translated, otherwise false.
     */
    CheerioTemplateParser.prototype.parseAttribute = function ($, element, attrName, contents, annotations, expressions, extract, translate) {
        // Try to get the name of the target attribute.
        var targetAttrName = this.config.attributePattern.getTargetName(attrName);
        // Ignore the node if it does not match the attribute pattern.
        if (targetAttrName == null) {
            return;
        }
        // Is this a direct or orphaned annotation?
        if (!(targetAttrName in element.attribs)) {
            if (this.config.allowDirectAnnotation) {
                var annotation = new template_1.AttributeAnnotation($(element), attrName, targetAttrName, attrName, translate != null);
                if (!extract) {
                    // Add the attribute content to the content list.
                    contents.push(new template_1.AttributeContent(annotation, expressions, this.contentHash, this.templateLanguage, this.templateWhitespace));
                }
                else {
                    if (translate) {
                        throw new Error("A translate annotation within a translatable element can only contain the value '" + chalk_1.default.cyan("no") + "'.");
                    }
                    // Add the annotation to the annotation list, so it can be cleaned later.
                    contents.push(new template_1.AttributeContent(annotation, expressions, this.contentHash, this.templateLanguage, this.templateWhitespace));
                }
                // Add the annotation to the annotation list, so it can be cleaned later.
                annotations.push(annotation);
            }
            else {
                throw new Error("An orphaned translate annotation was found.");
            }
        }
        // This is a normal annotation with a corresponding target attribute.
        else {
            var annotation = new template_1.AttributeAnnotation($(element), attrName, targetAttrName, targetAttrName, translate != null);
            if (!extract) {
                if (!annotation.translate) {
                    if (translate === false) {
                        throw new Error("A translate annotation within a non-translatable element can only contain the value '' or '" + chalk_1.default.cyan("yes") + "'.");
                    }
                }
                else if (!annotation.hasOptions) {
                    // Add the attribute content to the content list.
                    contents.push(new template_1.AttributeContent(annotation, expressions, this.contentHash, this.templateLanguage, this.templateWhitespace));
                }
                else {
                    // Add the attribute content to the content list.
                    contents.push(new template_1.AttributeContent(annotation, expressions, this.contentHash, this.templateLanguage, this.templateWhitespace));
                }
            }
            else {
                if (!annotation.translate) {
                    if (!translate) {
                        throw new Error("A translate annotation within a non-translatable element can only contain the value '' or '" + chalk_1.default.cyan("yes") + "'.");
                    }
                }
                else if (!annotation.hasOptions) {
                    if (translate) {
                        throw new Error("A translate annotation within a translatable element can only contain the value '" + chalk_1.default.cyan("no") + "'.");
                    }
                    // Add the annotation to the annotation list, so it can be cleaned later.
                    contents.push(new template_1.AttributeContent(annotation, expressions, this.contentHash, this.templateLanguage, this.templateWhitespace));
                }
                else {
                    throw new Error("A translate annotation within translatable content can only contain the value '', '" + chalk_1.default.cyan("yes") + "' or '" + chalk_1.default.cyan("no") + "'.");
                }
            }
            // Add the annotation to the annotation list, so it can be cleaned later.
            annotations.push(annotation);
        }
    };
    return CheerioTemplateParser;
}());
exports.CheerioTemplateParser = CheerioTemplateParser;
//# sourceMappingURL=template-parser.js.map