"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AttributePattern = exports.TemplateParserConfig = void 0;
var tslib_1 = require("tslib");
var chalk_1 = tslib_1.__importDefault(require("chalk"));
/*
 * Represents the parser configuration.
 */
var TemplateParserConfig = /** @class */ (function () {
    /**
     * Creates a new instance of the TemplateParserConfig type.
     * @param config The config object from which the instance should be created.
     */
    function TemplateParserConfig(config) {
        this.attributeName = config.attributeName;
        this.attributePattern = new AttributePattern(config.attributePattern, "attributePattern");
        this.allowDirectAnnotation = config.allowDirectAnnotation;
    }
    return TemplateParserConfig;
}());
exports.TemplateParserConfig = TemplateParserConfig;
/**
 * Represents an attribute pattern, which consist of a target attribute name,
 * represented by a '*', combined with a prefix and/or a postfix.
 */
var AttributePattern = /** @class */ (function () {
    /**
     * Creates a new instance of the AttributePattern type.
     * @param pattern The pattern to match, which must contain a prefix and/or postfix and exactly one '*'.
     * @param optionName The name of the config option for which this instance is created.
     */
    function AttributePattern(pattern, optionName) {
        this._pattern = pattern.split("*");
        if (this._pattern.length !== 2 || pattern.length < 2) {
            throw new Error("The '" + chalk_1.default.cyan(optionName) + "' option must contain a prefix and/or postfix and exactly one '" + chalk_1.default.cyan("*") + "'.");
        }
    }
    /**
     * Gets the name of the specified attribute without the prefix and postfix defined in the pattern.
     * @param matchAttrName The name of the attribute matched by the pattern.
     * @returns The attribute name without the prefix and postfix specified in the pattern, or null if the name does not match the pattern.
     */
    AttributePattern.prototype.getTargetName = function (matchAttrName) {
        if (matchAttrName.length > this._pattern[0].length + this._pattern[1].length) {
            if (matchAttrName.substring(0, this._pattern[0].length) === this._pattern[0] &&
                matchAttrName.substring(matchAttrName.length - this._pattern[1].length) === this._pattern[1]) {
                return matchAttrName.slice(this._pattern[0].length, matchAttrName.length - this._pattern[1].length);
            }
        }
        return null;
    };
    /**
     * Gets the name of the specified attribute with the prefix and postfix defined in the pattern.
     * @param targetAttrName The name of the target attribute.
     * @returns The attribute name that, for the specified target attribute name, would match the pattern.
     */
    AttributePattern.prototype.getMatchedName = function (targetAttrName) {
        return this._pattern[0] + targetAttrName + this._pattern[1];
    };
    return AttributePattern;
}());
exports.AttributePattern = AttributePattern;
//# sourceMappingURL=template-parser-config.js.map