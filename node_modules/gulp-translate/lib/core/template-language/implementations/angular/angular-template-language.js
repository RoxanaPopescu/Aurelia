"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AngularTemplateLanguage = void 0;
/**
 * Represents an ITemplateLanguage implementation that supports the Angular templating language.
 */
var AngularTemplateLanguage = /** @class */ (function () {
    function AngularTemplateLanguage() {
    }
    /**
     * Gets the standard, parser-safe HTML for the template.
     * All binding expressions will be replaced with placeholders of the form '{{index}}',
     * and the original expression will be added to the expressions array at that index.
     * @param template The HTML string representing the template in which expressions should be replaced with placeholders.
     * @param expressions The array to which the original expressions should be added.
     */
    AngularTemplateLanguage.prototype.toStandardHtml = function (template, expressions) {
        var result = "";
        var sequenceStartIndex = 0;
        var expectOpenBrace = false;
        var expectCloseBrace = false;
        var braceDepth = 0;
        var quoteChar = null;
        var escape = false;
        for (var i = 0; i < template.length; i++) {
            var c = template[i];
            if (braceDepth === 0 && !expectCloseBrace) {
                if (c === "{") {
                    if (expectOpenBrace) {
                        expectOpenBrace = false;
                        braceDepth++;
                        result += template.substring(sequenceStartIndex, i - 1);
                        sequenceStartIndex = i - 1;
                    }
                    else {
                        expectOpenBrace = true;
                    }
                }
                else {
                    expectOpenBrace = false;
                }
            }
            else {
                if (quoteChar != null) {
                    if (c === "\\" && !escape) {
                        escape = true;
                    }
                    else {
                        if (c === quoteChar && !escape) {
                            quoteChar = null;
                        }
                        escape = false;
                    }
                }
                else if (c === '"' || c === "'" || c === "`") {
                    quoteChar = c;
                }
                else if (c === "{") {
                    braceDepth++;
                }
                else if (c === "}") {
                    if (expectCloseBrace) {
                        expectCloseBrace = false;
                        expressions.push(template.substring(sequenceStartIndex, i + 1));
                        result += "{{" + (expressions.length - 1) + "}}";
                        sequenceStartIndex = i + 1;
                    }
                    else {
                        if (braceDepth === 0) {
                            throw new Error("Unbalanced braces in expression.");
                        }
                        braceDepth--;
                        if (braceDepth === 0) {
                            expectCloseBrace = true;
                        }
                    }
                }
                else {
                    expectCloseBrace = false;
                }
            }
        }
        if (quoteChar != null) {
            throw new Error("Unbalanced quotes in expression.");
        }
        if (braceDepth < 0) {
            throw new Error("Unbalanced braces in expression.");
        }
        if (escape) {
            throw new Error("Expected character after escape.");
        }
        return result + template.substring(sequenceStartIndex, template.length);
    };
    /**
     * Gets the non-standard, non-parser-safe HTML for the template.
     * All binding expression placeholders of the form '{{index}}' will be replaced with, the
     * original expressions, which are assumed to be in the expressions array at that index.
     * @param template The HTML string representing the template in which expressions have been replaced with placeholders.
     * @param expressions The array containing the original expressions for the placeholders in the template.
     */
    AngularTemplateLanguage.prototype.toTemplateHtml = function (template, expressions) {
        return template.replace(/\{{(\d+)}}/g, function (match, index) { return expressions[index]; });
    };
    return AngularTemplateLanguage;
}());
exports.AngularTemplateLanguage = AngularTemplateLanguage;
//# sourceMappingURL=angular-template-language.js.map