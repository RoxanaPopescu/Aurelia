"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImportFile = void 0;
var tslib_1 = require("tslib");
var fs = tslib_1.__importStar(require("fs"));
var path = tslib_1.__importStar(require("path"));
var mkdirp_1 = tslib_1.__importDefault(require("mkdirp"));
var chalk_1 = tslib_1.__importDefault(require("chalk"));
var json_format_1 = require("./formats/json-format");
var csv_format_1 = require("./formats/csv-format");
/**
 * Represents localized contents to be imported into templates, where each content instance is identified by an id,
 * and scoped to a file or folder path.
 */
var ImportFile = /** @class */ (function () {
    function ImportFile() {
        /**
         * The contents of the file.
         */
        this.contents = {};
    }
    /**
     * Parses the specified text, creating a new instance of the ImportFile type.
     * @param text The string to parse.
     * @param fileNameExt The file name extension for the format to parse.
     * @returns The new instance of the ImportFile type.
     */
    ImportFile.parse = function (text, fileNameExt) {
        var format = ImportFile.getFormat(fileNameExt);
        return format.parse(text);
    };
    /**
     * Loads the specified file, creating a new instance of the ImportFile type.
     * @param filePath The absolute path for the file to load.
     * @param encoding The file encoding to use, or undefined to use UTF8.
     * @returns The new instance of the ImportFile type.
     */
    ImportFile.load = function (filePath, encoding) {
        if (encoding === void 0) { encoding = "utf8"; }
        var text = fs.readFileSync(filePath, { encoding: encoding });
        return ImportFile.parse(text, path.extname(filePath));
    };
    /**
     * Creates a new instance of the appropiate IExportFileFormat type, based on the specified file path.
     * @param fileNameExt The file name extension for which a format should be created.
     * @returns The new instance of the IExportFileFormat type.
     */
    ImportFile.getFormat = function (fileNameExt) {
        switch (fileNameExt) {
            case ".json":
                return new json_format_1.JsonImportFileFormat();
            case ".csv":
                return new csv_format_1.CsvImportFileFormat();
            default:
                throw new Error("The file format '" + chalk_1.default.magenta(fileNameExt) + "' is not supported.");
        }
    };
    /**
     * Sets the specified content, scoped to the specified path.
     * @param scopePath The relative file or folder path for which the content should be returned.
     * @param id The id identifying the content.
     * @param content The content to set.
     */
    ImportFile.prototype.set = function (scopePath, id, content) {
        var scope = this.contents[scopePath] || (this.contents[scopePath] = {});
        scope[id] = content;
    };
    /**
     * Gets the content matching the specified id and scope path.
     * @param scopePath The relative file or folder path for which the content should be returned.
     * @param id The id identifying the content.
     * @returns The content matching the specified path and id, or undefined if no content is found.
     */
    ImportFile.prototype.get = function (scopePath, id) {
        var e_1, _a;
        // Get the set of paths in the file that contain the specified path.
        // The path length is used as betterness criteria.
        var basePaths = Object.keys(this.contents)
            .filter(function (p) { return scopePath.indexOf(p) === 0; })
            .sort(function (a, b) { return b.length - a.length; });
        var content;
        try {
            for (var basePaths_1 = tslib_1.__values(basePaths), basePaths_1_1 = basePaths_1.next(); !basePaths_1_1.done; basePaths_1_1 = basePaths_1.next()) {
                var basePath = basePaths_1_1.value;
                content = this.contents[basePath][id];
                if (content != null) {
                    return content;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (basePaths_1_1 && !basePaths_1_1.done && (_a = basePaths_1.return)) _a.call(basePaths_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return undefined;
    };
    /**
     * Serializes the contents to a JSON string.
     * @returns A JSON string representing the file contents.
     */
    ImportFile.prototype.stringify = function (fileNameExt) {
        var format = ImportFile.getFormat(fileNameExt);
        return format.stringify(this);
    };
    /**
     * Saves the contents to the specified file.
     * @param filePath The absolute path for the file to which the contents should be saved.
     * @param encoding The file encoding to use, or undefined to use UTF8.
     * @returns A promise that will be resolved when the file has been saved.
     */
    ImportFile.prototype.save = function (filePath, encoding) {
        if (encoding === void 0) { encoding = "utf8"; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var text;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        text = this.stringify(path.extname(filePath));
                        return [4 /*yield*/, mkdirp_1.default(path.dirname(filePath))];
                    case 1:
                        _a.sent();
                        fs.writeFileSync(filePath, text, { encoding: encoding });
                        return [2 /*return*/];
                }
            });
        });
    };
    return ImportFile;
}());
exports.ImportFile = ImportFile;
//# sourceMappingURL=import-file.js.map