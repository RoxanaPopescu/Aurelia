"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContentFile = void 0;
var tslib_1 = require("tslib");
var fs = tslib_1.__importStar(require("fs"));
var path = tslib_1.__importStar(require("path"));
var mkdirp_1 = tslib_1.__importDefault(require("mkdirp"));
var chalk_1 = tslib_1.__importDefault(require("chalk"));
var json_format_1 = require("./formats/json-format");
var csv_format_1 = require("./formats/csv-format");
/**
 * Represents localizable or localized contents, where each content instance is identified by an id.
 */
var ContentFile = /** @class */ (function () {
    function ContentFile() {
        /**
         * The contents of the file.
         */
        this.contents = {};
    }
    /**
     * Parses the specified text, creating a new instance of the ContentFile type.
     * @param text The string to parse.
     * @param fileNameExt The file name extension for the format to parse.
     * @returns The new instance of the ContentFile type.
     */
    ContentFile.parse = function (text, fileNameExt) {
        var format = ContentFile.getFormat(fileNameExt);
        return format.parse(text);
    };
    /**
     * Loads the specified file, creating a new instance of the ContentFile type.
     * @param filePath The absolute path for the file to load.
     * @param encoding The file encoding to use, or undefined to use UTF8.
     * @returns The new instance of the ContentFile type.
     */
    ContentFile.load = function (filePath, encoding) {
        if (encoding === void 0) { encoding = "utf8"; }
        var text = fs.readFileSync(filePath, { encoding: encoding });
        return ContentFile.parse(text, path.extname(filePath));
    };
    /**
     * Creates a new instance of the appropiate IExportFileFormat type, based on the specified file path.
     * @param fileNameExt The file name extension for which a format should be created.
     * @returns The new instance of the IExportFileFormat type.
     */
    ContentFile.getFormat = function (fileNameExt) {
        switch (fileNameExt) {
            case ".json":
                return new json_format_1.JsonContentFileFormat();
            case ".csv":
                return new csv_format_1.CsvContentFileFormat();
            default:
                throw new Error("The file format '" + chalk_1.default.magenta(fileNameExt) + "' is not supported.");
        }
    };
    /**
     * Sets the specified content.
     * @param id The id identifying the content.
     * @param content The content to set.
     */
    ContentFile.prototype.set = function (id, content) {
        this.contents[id] = content;
    };
    /**
     * Gets the content matching the specified id.
     * @param id The id identifying the content.
     * @returns The content matching the specified id, or undefined if no content is found.
     */
    ContentFile.prototype.get = function (id) {
        return this.contents[id];
    };
    /**
     * Serializes the contents to a JSON string.
     * @returns A JSON string representing the file contents.
     */
    ContentFile.prototype.stringify = function (fileNameExt) {
        var format = ContentFile.getFormat(fileNameExt);
        return format.stringify(this);
    };
    /**
     * Saves the contents to the specified file.
     * @param filePath The absolute path for the file to which the contents should be saved.
     * @param encoding The file encoding to use, or undefined to use UTF8.
     * @returns A promise that will be resolved when the file has been saved.
     */
    ContentFile.prototype.save = function (filePath, encoding) {
        if (encoding === void 0) { encoding = "utf8"; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var text;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        text = this.stringify(path.extname(filePath));
                        return [4 /*yield*/, mkdirp_1.default(path.dirname(filePath))];
                    case 1:
                        _a.sent();
                        fs.writeFileSync(filePath, text, { encoding: encoding });
                        return [2 /*return*/];
                }
            });
        });
    };
    return ContentFile;
}());
exports.ContentFile = ContentFile;
//# sourceMappingURL=content-file.js.map