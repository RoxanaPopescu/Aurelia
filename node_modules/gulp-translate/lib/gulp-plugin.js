"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GulpPlugin = void 0;
var tslib_1 = require("tslib");
var through = tslib_1.__importStar(require("through2"));
var plugin_error_1 = tslib_1.__importDefault(require("plugin-error"));
var plugin_1 = require("./plugin/plugin");
var gulp_file_1 = require("./gulp-file");
/* tslint:disable-next-line: no-require-imports no-var-requires */
var packageJson = require("../package.json");
/**
 * Represents a Gulp plugin, implemented as a wrapper around the translate plugin.
 */
var GulpPlugin = /** @class */ (function () {
    /**
     * Creates a new instance of the GulpPlugin type.
     * @param config The plugin configuration to use, or undefined to use the default.
     */
    function GulpPlugin(config) {
        this.plugin = new plugin_1.Plugin(config);
    }
    /**
     * Exports the localized content from the HTML file being processed, into a localizable JSON file.
     * @param config The command configuration to use, or undefined to use the default.
     * @returns A stream transform for processing files.
     */
    GulpPlugin.prototype.export = function (config) {
        return this.createTransform(this.plugin.export(config));
    };
    /**
     * Imports the localized content from a localized JSON file, into the HTML file being processed.
     * @param config The command configuration to use.
     * @returns A stream transform for processing files.
     */
    GulpPlugin.prototype.import = function (config) {
        return this.createTransform(this.plugin.import(config));
    };
    /**
     * Simulates translation by creating an import file based on the content of the export file, optionally applying pseudo-localization to the content.
     * @param config The command configuration to use, or undefined to use the default.
     * @returns A stream transform for processing files.
     */
    GulpPlugin.prototype.translate = function (config) {
        return this.createTransform(this.plugin.translate(config));
    };
    /**
     * Creates a stream transform that processes files using the specified task.
     */
    GulpPlugin.prototype.createTransform = function (task) {
        var _this = this;
        // Return the stream transform.
        return through.obj(function (vinyl, encoding, callback) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var error_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 4, , 5]);
                        // Don't drop null-files from the stream.
                        if (vinyl.isNull()) {
                            callback(null, vinyl);
                            return [2 /*return*/];
                        }
                        // Process the buffer contents.
                        if (!vinyl.isBuffer()) {
                            throw new Error("This plugin command only supports buffers.");
                        }
                        if (!(task.process instanceof Function)) return [3 /*break*/, 2];
                        // Process the file.
                        return [4 /*yield*/, task.process(new gulp_file_1.GulpFile(vinyl))
                                // Notify stream engine that we are done with this file and push it back into the stream.
                                .then(function (gulpFile) { return callback(null, gulpFile.vinyl); })];
                    case 1:
                        // Process the file.
                        _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        // Notify stream engine that we are all done.
                        callback(null, vinyl);
                        _a.label = 3;
                    case 3: return [3 /*break*/, 5];
                    case 4:
                        error_1 = _a.sent();
                        callback(new plugin_error_1.default(packageJson.name, error_1.message));
                        return [2 /*return*/];
                    case 5: return [2 /*return*/];
                }
            });
        }); }, function (callback) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(task.finalize instanceof Function)) return [3 /*break*/, 2];
                        // Finalize the task.
                        return [4 /*yield*/, task.finalize()
                                // Notify stream engine that we are all done.
                                .then(function (gulpFile) { return callback(); })];
                    case 1:
                        // Finalize the task.
                        _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        // Notify stream engine that we are all done.
                        callback();
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        }); });
    };
    return GulpPlugin;
}());
exports.GulpPlugin = GulpPlugin;
//# sourceMappingURL=gulp-plugin.js.map