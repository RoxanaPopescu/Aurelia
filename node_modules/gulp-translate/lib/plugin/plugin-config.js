"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PluginConfig = void 0;
var tslib_1 = require("tslib");
var chalk_1 = tslib_1.__importDefault(require("chalk"));
var null_template_language_1 = require("../core/template-language/implementations/null/null-template-language");
var aurelia_template_language_1 = require("../core/template-language/implementations/aurelia/aurelia-template-language");
var angular_template_language_1 = require("../core/template-language/implementations/angular/angular-template-language");
/**
 * Represents the plugin configuration.
 */
var PluginConfig = /** @class */ (function () {
    /**
     * Creates a new instance of the PluginConfig type.
     * @param config The config object from which the instance should be created.
     */
    function PluginConfig(config) {
        /**
         * The name of the attribute identifying elements whose content
         * should be translated.
         */
        this.attributeName = "translate";
        /**
         * The pattern used when identifying attributes whose content should be
         * translated, where '*' represents the name of the target attribute.
         */
        this.attributePattern = "*.translate";
        /**
         * True to enable direct annotations of attributes, such that if the
         * target attribute does not exist, the attribute matched by the attribute
         * pattern is assumed to be the attribute containing the content. This
         * means, that if no options need to be specified, we can just change
         * the attribute name to match the pattern, instead of adding a separate
         * annotation attribute. Note however, that this also means that orphaned
         * annotations will not be treated as errors, as they will be assumed to
         * contain localizable content. If enabled, warnings may be logged during
         * export, if the content looks suspiciously like an annotation.
         */
        this.allowDirectAnnotation = false;
        /**
         * True to prefix the ids of content found in content files with the
         * relative file path of the content file, without the extension.
         * Enable this to keep the ids in content files short, thus making them
         * easier to work with in code.
         * Note that ids starting with "/" or "./" will not be prefixed.
         * An example of a prefixed id would be "./foo/bar:id", where './foo/bar'
         * is the file path without the extension and 'id' is a id in the file.
         */
        this.prefixIdsInContentFiles = false;
        /**
         * The length of the hash identifying content, in the range [1, 32].
         */
        this.hashLength = 9;
        if (config == undefined) {
            return;
        }
        if (config.attributeName != undefined) {
            this.attributeName = config.attributeName;
        }
        if (config.attributePattern != undefined) {
            this.attributePattern = config.attributePattern;
        }
        if (config.allowDirectAnnotation != undefined) {
            this.allowDirectAnnotation = config.allowDirectAnnotation;
        }
        if (config.prefixIdsInContentFiles != undefined) {
            this.prefixIdsInContentFiles = config.prefixIdsInContentFiles;
        }
        this.templateLanguage = this.getTemplateLanguage(config.templateLanguage);
        if (config.hashLength != undefined) {
            if (config.hashLength < 1 || config.hashLength > 32) {
                throw new Error("The '" + chalk_1.default.cyan("hashLength") + "' option must be a number in the range " + chalk_1.default.cyan("[1, 32]") + ".");
            }
            this.hashLength = config.hashLength;
        }
    }
    /**
     * Gets a named template language implementation, or the specified instance.
     */
    PluginConfig.prototype.getTemplateLanguage = function (nameOrInstance) {
        if (nameOrInstance == null) {
            return new null_template_language_1.NullTemplateLanguage();
        }
        if (typeof nameOrInstance === "string") {
            switch (nameOrInstance) {
                case "aurelia": return new aurelia_template_language_1.AureliaTemplateLanguage();
                case "angular": return new angular_template_language_1.AngularTemplateLanguage();
                default: throw new Error("The template language '" + chalk_1.default.cyan(nameOrInstance) + "' is not supported.");
            }
        }
        return nameOrInstance;
    };
    return PluginConfig;
}());
exports.PluginConfig = PluginConfig;
//# sourceMappingURL=plugin-config.js.map