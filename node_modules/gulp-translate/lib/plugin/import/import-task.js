"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImportTask = void 0;
var tslib_1 = require("tslib");
var path = tslib_1.__importStar(require("path"));
var chalk_1 = tslib_1.__importDefault(require("chalk"));
var import_file_1 = require("../../core/file-formats/import/import-file");
var content_file_1 = require("../../core/file-formats/content/content-file");
var utilities_1 = require("../../core/utilities");
var utilities_2 = require("../utilities");
/**
 * Represents the task.
 */
var ImportTask = /** @class */ (function () {
    /**
     * Creates a new instance of the ImportTask type.
     * @param pluginConfig The plugin configuration to use.
     * @param taskConfig The task configuration to use.
     * @param templateParser The ITemplateParser instance to use.
     */
    function ImportTask(pluginConfig, taskConfig, templateParser) {
        this._pluginConfig = pluginConfig;
        this._taskConfig = taskConfig;
        this._templateParser = templateParser;
        // Create the import file instances.
        this._importContentFiles = this.getContentFiles(taskConfig);
    }
    /**
     * Processes the specified file.
     * @param file The file to process.
     * @returns A promise that will be resolved with the processed file.
     */
    ImportTask.prototype.process = function (file) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var filePathRelativeToCwd, filePathRelativeToBase, contentFile, _a, _b, key, id, localizedContent, contentTemplate, e_1_1, template, _c, _d, content, localizedContent, contentTemplate, e_2_1, error_1;
            var e_1, _e, e_2, _f;
            return tslib_1.__generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        filePathRelativeToCwd = utilities_2.getRelativePath(file.path);
                        filePathRelativeToBase = utilities_2.getRelativePath(file.path, this._taskConfig.baseFilePath || file.base);
                        _g.label = 1;
                    case 1:
                        _g.trys.push([1, 20, , 21]);
                        if (!(path.extname(filePathRelativeToBase) !== ".html")) return [3 /*break*/, 10];
                        contentFile = content_file_1.ContentFile.parse(file.contents, path.extname(file.path));
                        _g.label = 2;
                    case 2:
                        _g.trys.push([2, 7, 8, 9]);
                        _a = tslib_1.__values(Object.keys(contentFile.contents)), _b = _a.next();
                        _g.label = 3;
                    case 3:
                        if (!!_b.done) return [3 /*break*/, 6];
                        key = _b.value;
                        id = key;
                        // If enabled, prefix the content id with the relative file path.
                        if (this._pluginConfig.prefixIdsInContentFiles) {
                            id = utilities_1.getPrefixedContentId(id, filePathRelativeToBase);
                        }
                        return [4 /*yield*/, this.getImportContent(this._taskConfig, this._importContentFiles, filePathRelativeToBase, filePathRelativeToCwd, id)];
                    case 4:
                        localizedContent = _g.sent();
                        // Replace the content, if found.
                        if (localizedContent != null) {
                            // If enabled, remove the localization attributes from the content.
                            if (this._taskConfig.preserveAnnotations !== "all") {
                                contentTemplate = this._templateParser.parse(localizedContent);
                                contentTemplate.clean(this._taskConfig.preserveAnnotations);
                                localizedContent = contentTemplate.toString();
                            }
                            contentFile.set(key, localizedContent);
                        }
                        _g.label = 5;
                    case 5:
                        _b = _a.next();
                        return [3 /*break*/, 3];
                    case 6: return [3 /*break*/, 9];
                    case 7:
                        e_1_1 = _g.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 9];
                    case 8:
                        try {
                            if (_b && !_b.done && (_e = _a.return)) _e.call(_a);
                        }
                        finally { if (e_1) throw e_1.error; }
                        return [7 /*endfinally*/];
                    case 9:
                        // Replace the file contents.
                        file.contents = contentFile.stringify(path.extname(file.path));
                        return [3 /*break*/, 19];
                    case 10:
                        template = this._templateParser.parse(file.contents);
                        _g.label = 11;
                    case 11:
                        _g.trys.push([11, 16, 17, 18]);
                        _c = tslib_1.__values(template.contents), _d = _c.next();
                        _g.label = 12;
                    case 12:
                        if (!!_d.done) return [3 /*break*/, 15];
                        content = _d.value;
                        return [4 /*yield*/, this.getImportContent(this._taskConfig, this._importContentFiles, filePathRelativeToBase, filePathRelativeToCwd, content.id)];
                    case 13:
                        localizedContent = _g.sent();
                        // Replace the content, if found.
                        if (localizedContent != null) {
                            // If enabled, remove the localization attributes from the content.
                            if (this._taskConfig.preserveAnnotations !== "all") {
                                contentTemplate = this._templateParser.parse(localizedContent);
                                contentTemplate.clean(this._taskConfig.preserveAnnotations);
                                localizedContent = contentTemplate.toString();
                            }
                            content.content = localizedContent;
                        }
                        _g.label = 14;
                    case 14:
                        _d = _c.next();
                        return [3 /*break*/, 12];
                    case 15: return [3 /*break*/, 18];
                    case 16:
                        e_2_1 = _g.sent();
                        e_2 = { error: e_2_1 };
                        return [3 /*break*/, 18];
                    case 17:
                        try {
                            if (_d && !_d.done && (_f = _c.return)) _f.call(_c);
                        }
                        finally { if (e_2) throw e_2.error; }
                        return [7 /*endfinally*/];
                    case 18:
                        // If enabled, remove the localization attributes from the template.
                        template.clean(this._taskConfig.preserveAnnotations);
                        // Replace the file contents.
                        file.contents = template.toString();
                        _g.label = 19;
                    case 19: 
                    // Return the processed file.
                    return [2 /*return*/, file];
                    case 20:
                        error_1 = _g.sent();
                        throw new Error("Error while processing file " + chalk_1.default.magenta(filePathRelativeToCwd) + ":\n" + error_1.message);
                    case 21: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Loads the import files specified in the task config.
     * @param config The task config.
     * @returns The array of import file instances.
     */
    ImportTask.prototype.getContentFiles = function (config) {
        var importContentFiles = config.importFilePaths.map(function (importFilePath) {
            try {
                return import_file_1.ImportFile.load(importFilePath);
            }
            catch (error) {
                throw new Error("Error while loading file " + chalk_1.default.magenta(importFilePath) + ":\n" + error.message);
            }
        });
        return importContentFiles;
    };
    /**
     * Gets the first matching content in the import files, or null if the content should be ignored.
     * @param config The task config.
     * @param importContentFiles The import file instances in which to look for the content.
     * @param filePathRelativeToBase The file path, relative to the base path, for the file being processed.
     * @param filePathRelativeToCwd The file path, relative to the current working directory, for the file being processed.
     * @param id The id for which content should be returned.
     * @returns The matching content, or null if no content is found and missing content is allowed.
     */
    ImportTask.prototype.getImportContent = function (config, importContentFiles, filePathRelativeToBase, filePathRelativeToCwd, id) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var localizedContent, importContentFiles_1, importContentFiles_1_1, importContentFile, missingContentHandlerResult, reason_1;
            var e_3, _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        try {
                            for (importContentFiles_1 = tslib_1.__values(importContentFiles), importContentFiles_1_1 = importContentFiles_1.next(); !importContentFiles_1_1.done; importContentFiles_1_1 = importContentFiles_1.next()) {
                                importContentFile = importContentFiles_1_1.value;
                                localizedContent = importContentFile.get(filePathRelativeToBase, id);
                                if (localizedContent !== undefined) {
                                    break;
                                }
                            }
                        }
                        catch (e_3_1) { e_3 = { error: e_3_1 }; }
                        finally {
                            try {
                                if (importContentFiles_1_1 && !importContentFiles_1_1.done && (_a = importContentFiles_1.return)) _a.call(importContentFiles_1);
                            }
                            finally { if (e_3) throw e_3.error; }
                        }
                        if (!(localizedContent === undefined && config.missingContentHandler != null)) return [3 /*break*/, 6];
                        missingContentHandlerResult = config.missingContentHandler(id, filePathRelativeToBase);
                        if (!(missingContentHandlerResult instanceof Promise)) return [3 /*break*/, 5];
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, missingContentHandlerResult];
                    case 2:
                        localizedContent = _b.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        reason_1 = _b.sent();
                        // If the reason for the rejection is an error, we assume something actually went wrong.
                        if (reason_1 instanceof Error) {
                            throw reason_1;
                        }
                        return [3 /*break*/, 4];
                    case 4: return [3 /*break*/, 6];
                    case 5:
                        localizedContent = missingContentHandlerResult;
                        _b.label = 6;
                    case 6:
                        // If still not found, handle the content as missing.
                        if (localizedContent === undefined) {
                            if (config.missingContentHandling === "warn") {
                                console.log(chalk_1.default.bgYellow.black("WARN") + " The content for id '" + chalk_1.default.cyan(id) + "' in file '" + chalk_1.default.magenta(filePathRelativeToCwd) + "' was not found in the import file or by the missing content handler.");
                            }
                            else if (config.missingContentHandling === "error") {
                                throw new Error("The content for id '" + chalk_1.default.cyan(id) + "' in file '" + chalk_1.default.magenta(filePathRelativeToCwd) + "' was not found in the import file or by the missing content handler.");
                            }
                            localizedContent = null;
                        }
                        return [2 /*return*/, localizedContent];
                }
            });
        });
    };
    return ImportTask;
}());
exports.ImportTask = ImportTask;
//# sourceMappingURL=import-task.js.map