"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loader = void 0;
var tslib_1 = require("tslib");
var path = tslib_1.__importStar(require("path"));
var loaderUtils = tslib_1.__importStar(require("loader-utils"));
var minimatch = tslib_1.__importStar(require("minimatch"));
/* tslint:disable: no-submodule-imports */
var plugin_1 = require("gulp-translate/lib/plugin/plugin");
/* tslint:enable */
/**
 * Represents the loader function that will be called by Webpack.
 * @param fileContents The contents of the file being loaded.
 */
function loader(fileContents) {
    var e_1, _a;
    // Get a copy of the options for the translate plugin and import task.
    var options = tslib_1.__assign({}, loaderUtils.getOptions(this));
    // Get the path of the file being loaded.
    var filePath = this.resourcePath;
    var skipImport = false;
    // Skip the import if the file path matches any exclude globs.
    if (options.excludedFilePaths != null) {
        var excludeGlobs = options.excludedFilePaths.map(function (glob) { return path.resolve(glob); });
        if (excludeGlobs.some(function (glob) { return minimatch.match([filePath], glob).length > 0; })) {
            skipImport = true;
        }
    }
    if (!skipImport) {
        // Add the import file as a dependency for the file being loaded.
        if (options.importFilePath instanceof Array) {
            try {
                for (var _b = tslib_1.__values(options.importFilePath), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var importFilePath = _c.value;
                    this.addDependency(importFilePath);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        else if (options.importFilePath != null) {
            this.addDependency(options.importFilePath);
        }
    }
    else {
        // We need the export task to clean the templates, but we don't want to actually export anything.
        options.exportFilePath = undefined;
    }
    // Create the translate plugin.
    var plugin = new plugin_1.Plugin(options);
    // Create the task, which may be either an import task or an export task, depending on whether the import
    // should be skipped or not. If the import is skipped, the export task will simply clean the templates.
    var task = skipImport ? plugin.export(options) : plugin.import(options);
    // Create the file to be processed.
    var file = { contents: fileContents, path: filePath };
    // Process the file.
    var callback = this.async();
    task.process(file)
        .then(function (processedFile) { return callback(null, processedFile.contents); })
        .catch(callback);
}
exports.loader = loader;
//# sourceMappingURL=loader.js.map